{"ast":null,"code":"export default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef\n}) {\n  const mediaType = selectedTab === 1 ? {\n    video: true,\n    audio: true\n  } // Video with audio\n  : {\n    audio: true\n  }; // Audio only\n\n  if (!isRecording) {\n    // Clear previous recording data when starting new recording\n    setMediaURL(\"\");\n    setCountdown(60); // Reset the countdown\n    if (selectedTab === 1) {\n      setVideoBlob(null);\n    } else {\n      setAudioBlob(null);\n    }\n    console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n    navigator.mediaDevices.getUserMedia(mediaType).then(stream => {\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      mediaChunksRef.current = [];\n      mediaRecorder.start();\n      setIsRecording(true);\n      console.log('MediaRecorder started');\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            // Automatically stop recording when countdown reaches 0\n            if (mediaRecorder.state === \"recording\") {\n              console.log('Stopping recording due to countdown');\n              mediaRecorder.stop();\n              stream.getTracks().forEach(track => track.stop());\n              setIsRecording(false);\n            }\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      mediaRecorder.countdownInterval = countdownInterval;\n      mediaRecorder.addEventListener('dataavailable', event => {\n        if (event.data.size > 0) {\n          mediaChunksRef.current.push(event.data);\n          console.log('Data chunk received:', event.data.size, 'bytes');\n        }\n      });\n      mediaRecorder.addEventListener('stop', () => {\n        const mediaBlob = new Blob(mediaChunksRef.current, {\n          type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n        });\n        console.log('Created media blob:', {\n          type: mediaBlob.type,\n          size: mediaBlob.size\n        });\n        const url = URL.createObjectURL(mediaBlob);\n        setMediaURL(url);\n        if (selectedTab === 1) {\n          setVideoBlob(mediaBlob);\n          console.log('Video blob set:', mediaBlob);\n        } else {\n          setAudioBlob(mediaBlob);\n          console.log('Audio blob set:', mediaBlob);\n        }\n        setIsRecording(false);\n        mediaChunksRef.current = [];\n        clearInterval(mediaRecorder.countdownInterval);\n      });\n    }).catch(err => {\n      console.error('Error accessing media:', err);\n      setIsRecording(false);\n      alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n    });\n  } else {\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log('Recording stopped manually');\n    }\n  }\n}\n;\nconst handleReRecord = () => {\n  // Clear the current recording\n  setMediaURL(\"\");\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n\n  // Clear media chunks\n  mediaChunksRef.current = [];\n\n  // Stop any existing streams\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n  }\n\n  // Start new recording\n  handleMediaRecord();\n};","map":{"version":3,"names":["handleMediaRecord","selectedTab","isRecording","setIsRecording","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","mediaRecorderRef","mediaChunksRef","mediaType","video","audio","console","log","navigator","mediaDevices","getUserMedia","then","stream","mediaRecorder","MediaRecorder","current","start","countdownInterval","setInterval","prev","clearInterval","state","stop","getTracks","forEach","track","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","error","alert","handleReRecord"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["export default function  handleMediaRecord({selectedTab,\n          isRecording,\n          setIsRecording,\n          setMediaURL,\n          setCountdown,\n          setVideoBlob,\n          setAudioBlob,\n          mediaRecorderRef,\n          mediaChunksRef,}){\n    const mediaType = selectedTab === 1 \n      ? { video: true, audio: true }  // Video with audio\n      : { audio: true };              // Audio only\n\n    if (!isRecording) {\n      // Clear previous recording data when starting new recording\n      setMediaURL(\"\");\n      setCountdown(60); // Reset the countdown\n      if (selectedTab === 1) {\n        setVideoBlob(null);\n      } else {\n        setAudioBlob(null);\n      }\n\n      console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n\n      navigator.mediaDevices.getUserMedia(mediaType)\n        .then((stream) => {\n          const mediaRecorder = new MediaRecorder(stream);\n          mediaRecorderRef.current = mediaRecorder;\n          mediaChunksRef.current = [];\n\n          mediaRecorder.start();\n          setIsRecording(true);\n          console.log('MediaRecorder started');\n\n          const countdownInterval = setInterval(() => {\n            setCountdown((prev) => {\n              if (prev <= 1) {\n                clearInterval(countdownInterval);\n                // Automatically stop recording when countdown reaches 0\n                if (mediaRecorder.state === \"recording\") {\n                  console.log('Stopping recording due to countdown');\n                  mediaRecorder.stop();\n                  stream.getTracks().forEach(track => track.stop());\n                  setIsRecording(false);\n                }\n                return 0;\n              }\n              return prev - 1;\n            });\n          }, 1000);\n\n          mediaRecorder.countdownInterval = countdownInterval;\n\n          mediaRecorder.addEventListener('dataavailable', (event) => {\n            if (event.data.size > 0) {\n              mediaChunksRef.current.push(event.data);\n              console.log('Data chunk received:', event.data.size, 'bytes');\n            }\n          });\n\n          mediaRecorder.addEventListener('stop', () => {\n            const mediaBlob = new Blob(mediaChunksRef.current, {\n              type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n            });\n            console.log('Created media blob:', {\n              type: mediaBlob.type,\n              size: mediaBlob.size\n            });\n\n            const url = URL.createObjectURL(mediaBlob);\n            setMediaURL(url);\n\n            if (selectedTab === 1) {\n              setVideoBlob(mediaBlob);\n              console.log('Video blob set:', mediaBlob);\n            } else {\n              setAudioBlob(mediaBlob);\n              console.log('Audio blob set:', mediaBlob);\n            }\n\n            setIsRecording(false);\n            mediaChunksRef.current = [];\n            clearInterval(mediaRecorder.countdownInterval);\n          });\n        })\n        .catch((err) => {\n          console.error('Error accessing media:', err);\n          setIsRecording(false);\n          alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n        });\n    } else {\n      if (mediaRecorderRef.current) {\n        mediaRecorderRef.current.stop();\n        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n        clearInterval(mediaRecorderRef.current.countdownInterval);\n        setCountdown(0);\n        console.log('Recording stopped manually');\n      }\n    }\n  }; \n\n\n  const handleReRecord = () => {\n        // Clear the current recording\n        setMediaURL(\"\");\n        if (selectedTab === 1) {\n          setVideoBlob(null);\n        } else {\n          setAudioBlob(null);\n        }\n        \n        // Clear media chunks\n        mediaChunksRef.current = [];\n        \n        // Stop any existing streams\n        if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n          mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n        }\n        \n        // Start new recording\n        handleMediaRecord();\n      };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}