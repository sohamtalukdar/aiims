{"ast":null,"code":"export default function handleMediaRecord(_ref){let{selectedTab,isRecording,setIsRecording,setMediaURL,setCountdown,setVideoBlob,setAudioBlob,mediaRecorderRef,mediaChunksRef}=_ref;// Validate required parameters\nif(typeof setMediaURL!==\"function\"){throw new Error(\"setMediaURL must be a function\");}if(typeof setIsRecording!==\"function\"){throw new Error(\"setIsRecording must be a function\");}if(typeof setCountdown!==\"function\"){throw new Error(\"setCountdown must be a function\");}const mediaType=selectedTab===1?{video:true,audio:true}// Video with audio\n:{audio:true};// Audio only\nif(!isRecording){// Clear previous recording state\nsetMediaURL(\"\");setCountdown(60);// Reset countdown\nif(selectedTab===1){setVideoBlob(null);}else{setAudioBlob(null);}console.log(\"Starting media recording for:\",selectedTab===1?\"video\":\"audio\");// Request media access\nnavigator.mediaDevices.getUserMedia(mediaType).then(stream=>{const mediaRecorder=new MediaRecorder(stream);mediaRecorderRef.current=mediaRecorder;mediaChunksRef.current=[];mediaRecorder.start();setIsRecording(true);console.log(\"MediaRecorder started\");// Countdown logic\nconst countdownInterval=setInterval(()=>{setCountdown(prev=>{if(prev<=1){clearInterval(countdownInterval);// Automatically stop recording when countdown reaches 0\nif(mediaRecorder.state===\"recording\"){console.log(\"Stopping recording due to countdown\");mediaRecorder.stop();stream.getTracks().forEach(track=>track.stop());setIsRecording(false);}return 0;}return prev-1;});},1000);mediaRecorder.countdownInterval=countdownInterval;// Event: Data Available\nmediaRecorder.addEventListener(\"dataavailable\",event=>{if(event.data.size>0){mediaChunksRef.current.push(event.data);console.log(\"Data chunk received:\",event.data.size,\"bytes\");}});// Event: Stop\nmediaRecorder.addEventListener(\"stop\",()=>{const mediaBlob=new Blob(mediaChunksRef.current,{type:selectedTab===1?\"video/webm\":\"audio/webm\"});const url=URL.createObjectURL(mediaBlob);setMediaURL(url);if(selectedTab===1){setVideoBlob(mediaBlob);console.log(\"Video blob set:\",mediaBlob);}else{setAudioBlob(mediaBlob);console.log(\"Audio blob set:\",mediaBlob);}// Cleanup state\nsetIsRecording(false);mediaChunksRef.current=[];clearInterval(mediaRecorder.countdownInterval);});}).catch(err=>{console.error(\"Error accessing media:\",err);setIsRecording(false);alert(`Could not access your ${selectedTab===1?\"camera\":\"microphone\"}. Please check your browser settings.`);});}else{// Stop recording manually\nif(mediaRecorderRef.current){mediaRecorderRef.current.stop();mediaRecorderRef.current.stream.getTracks().forEach(track=>track.stop());clearInterval(mediaRecorderRef.current.countdownInterval);setCountdown(0);console.log(\"Recording stopped manually\");}}}export const handleReRecord=_ref2=>{let{setMediaURL,setVideoBlob,setAudioBlob,mediaChunksRef,mediaRecorderRef,selectedTab,handleMediaRecord,setIsRecording,setCountdown}=_ref2;// Validate required parameters\nif(typeof setMediaURL!==\"function\"){throw new Error(\"setMediaURL must be a function\");}console.log(\"Re-recording initiated\");// Clear the current recording state\nsetMediaURL(\"\");if(selectedTab===1){setVideoBlob(null);}else{setAudioBlob(null);}// Clear media chunks\nmediaChunksRef.current=[];// Stop any existing streams\nif(mediaRecorderRef.current&&mediaRecorderRef.current.stream){mediaRecorderRef.current.stream.getTracks().forEach(track=>track.stop());}// Start new recording\nhandleMediaRecord({selectedTab,isRecording:false,setIsRecording,setMediaURL,setCountdown,setVideoBlob,setAudioBlob,mediaRecorderRef,mediaChunksRef});};","map":{"version":3,"names":["handleMediaRecord","_ref","selectedTab","isRecording","setIsRecording","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","mediaRecorderRef","mediaChunksRef","Error","mediaType","video","audio","console","log","navigator","mediaDevices","getUserMedia","then","stream","mediaRecorder","MediaRecorder","current","start","countdownInterval","setInterval","prev","clearInterval","state","stop","getTracks","forEach","track","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","error","alert","handleReRecord","_ref2"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["export default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef,\n}) {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n  if (typeof setIsRecording !== \"function\") {\n    throw new Error(\"setIsRecording must be a function\");\n  }\n  if (typeof setCountdown !== \"function\") {\n    throw new Error(\"setCountdown must be a function\");\n  }\n\n  const mediaType =\n    selectedTab === 1\n      ? { video: true, audio: true } // Video with audio\n      : { audio: true }; // Audio only\n\n  if (!isRecording) {\n    // Clear previous recording state\n    setMediaURL(\"\");\n    setCountdown(60); // Reset countdown\n    if (selectedTab === 1) {\n      setVideoBlob(null);\n    } else {\n      setAudioBlob(null);\n    }\n\n    console.log(\"Starting media recording for:\", selectedTab === 1 ? \"video\" : \"audio\");\n\n    // Request media access\n    navigator.mediaDevices\n      .getUserMedia(mediaType)\n      .then((stream) => {\n        const mediaRecorder = new MediaRecorder(stream);\n        mediaRecorderRef.current = mediaRecorder;\n        mediaChunksRef.current = [];\n\n        mediaRecorder.start();\n        setIsRecording(true);\n        console.log(\"MediaRecorder started\");\n\n        // Countdown logic\n        const countdownInterval = setInterval(() => {\n          setCountdown((prev) => {\n            if (prev <= 1) {\n              clearInterval(countdownInterval);\n              // Automatically stop recording when countdown reaches 0\n              if (mediaRecorder.state === \"recording\") {\n                console.log(\"Stopping recording due to countdown\");\n                mediaRecorder.stop();\n                stream.getTracks().forEach((track) => track.stop());\n                setIsRecording(false);\n              }\n              return 0;\n            }\n            return prev - 1;\n          });\n        }, 1000);\n\n        mediaRecorder.countdownInterval = countdownInterval;\n\n        // Event: Data Available\n        mediaRecorder.addEventListener(\"dataavailable\", (event) => {\n          if (event.data.size > 0) {\n            mediaChunksRef.current.push(event.data);\n            console.log(\"Data chunk received:\", event.data.size, \"bytes\");\n          }\n        });\n\n        // Event: Stop\n        mediaRecorder.addEventListener(\"stop\", () => {\n          const mediaBlob = new Blob(mediaChunksRef.current, {\n            type: selectedTab === 1 ? \"video/webm\" : \"audio/webm\",\n          });\n          const url = URL.createObjectURL(mediaBlob);\n          setMediaURL(url);\n\n          if (selectedTab === 1) {\n            setVideoBlob(mediaBlob);\n            console.log(\"Video blob set:\", mediaBlob);\n          } else {\n            setAudioBlob(mediaBlob);\n            console.log(\"Audio blob set:\", mediaBlob);\n          }\n\n          // Cleanup state\n          setIsRecording(false);\n          mediaChunksRef.current = [];\n          clearInterval(mediaRecorder.countdownInterval);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error accessing media:\", err);\n        setIsRecording(false);\n        alert(\n          `Could not access your ${selectedTab === 1 ? \"camera\" : \"microphone\"}. Please check your browser settings.`\n        );\n      });\n  } else {\n    // Stop recording manually\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log(\"Recording stopped manually\");\n    }\n  }\n}\n\nexport const handleReRecord = ({\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaChunksRef,\n  mediaRecorderRef,\n  selectedTab,\n  handleMediaRecord,\n  setIsRecording,\n  setCountdown,\n}) => {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n\n  console.log(\"Re-recording initiated\");\n\n  // Clear the current recording state\n  setMediaURL(\"\");\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n\n  // Clear media chunks\n  mediaChunksRef.current = [];\n\n  // Stop any existing streams\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n  }\n\n  // Start new recording\n  handleMediaRecord({\n    selectedTab,\n    isRecording: false,\n    setIsRecording,\n    setMediaURL,\n    setCountdown,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef,\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}