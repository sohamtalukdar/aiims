{"ast":null,"code":"// Utility function to reset recording state\nconst resetRecordingState = ({\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  selectedTab\n}) => {\n  if (typeof setMediaURL !== 'function') {\n    console.error('setMediaURL is not a function:', setMediaURL);\n    return;\n  }\n  setMediaURL(\"\");\n  setCountdown(60);\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n};\n\n// Utility function to stop all media tracks\nconst stopMediaTracks = mediaRecorderRef => {\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n  }\n};\nexport default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef\n}) {\n  const mediaType = selectedTab === 1 ? {\n    video: true,\n    audio: true\n  } : {\n    audio: true\n  };\n  if (!isRecording) {\n    resetRecordingState({\n      setMediaURL,\n      setCountdown,\n      setVideoBlob,\n      setAudioBlob,\n      selectedTab\n    });\n    console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n    navigator.mediaDevices.getUserMedia(mediaType).then(stream => {\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      mediaChunksRef.current = [];\n      mediaRecorder.start();\n      setIsRecording(true);\n      console.log('MediaRecorder started');\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            if (mediaRecorder.state === \"recording\") {\n              console.log('Stopping recording due to countdown');\n              mediaRecorder.stop();\n              stopMediaTracks(mediaRecorderRef);\n              setIsRecording(false);\n            }\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      mediaRecorder.countdownInterval = countdownInterval;\n      mediaRecorder.addEventListener('dataavailable', event => {\n        if (event.data.size > 0) {\n          mediaChunksRef.current.push(event.data);\n          console.log('Data chunk received:', event.data.size, 'bytes');\n        }\n      });\n      mediaRecorder.addEventListener('stop', () => {\n        const mediaBlob = new Blob(mediaChunksRef.current, {\n          type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n        });\n        console.log('Created media blob:', {\n          type: mediaBlob.type,\n          size: mediaBlob.size\n        });\n        const url = URL.createObjectURL(mediaBlob);\n        setMediaURL(url);\n        if (selectedTab === 1) {\n          setVideoBlob(mediaBlob);\n          console.log('Video blob set:', mediaBlob);\n        } else {\n          setAudioBlob(mediaBlob);\n          console.log('Audio blob set:', mediaBlob);\n        }\n        setIsRecording(false);\n        mediaChunksRef.current = [];\n        clearInterval(mediaRecorder.countdownInterval);\n      });\n    }).catch(err => {\n      console.error('Error accessing media:', err);\n      setIsRecording(false);\n      alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n    });\n  } else {\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      stopMediaTracks(mediaRecorderRef);\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log('Recording stopped manually');\n    }\n  }\n}\nexport function handleReRecord({\n  selectedTab,\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef,\n  startNewRecording\n}) {\n  resetRecordingState({\n    setMediaURL,\n    setVideoBlob,\n    setAudioBlob,\n    selectedTab\n  });\n  mediaChunksRef.current = [];\n  stopMediaTracks(mediaRecorderRef);\n  if (startNewRecording) {\n    startNewRecording();\n  }\n}","map":{"version":3,"names":["resetRecordingState","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","selectedTab","console","error","stopMediaTracks","mediaRecorderRef","current","stream","getTracks","forEach","track","stop","handleMediaRecord","isRecording","setIsRecording","mediaChunksRef","mediaType","video","audio","log","navigator","mediaDevices","getUserMedia","then","mediaRecorder","MediaRecorder","start","countdownInterval","setInterval","prev","clearInterval","state","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","alert","handleReRecord","startNewRecording"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["// Utility function to reset recording state\nconst resetRecordingState = ({ setMediaURL, setCountdown, setVideoBlob, setAudioBlob, selectedTab }) => {\n  if (typeof setMediaURL !== 'function') {\n    console.error('setMediaURL is not a function:', setMediaURL);\n    return;\n  }\n  setMediaURL(\"\");\n  setCountdown(60); \n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n};\n\n\n// Utility function to stop all media tracks\nconst stopMediaTracks = (mediaRecorderRef) => {\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n      mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n  }\n};\n\nexport default function handleMediaRecord({\n  selectedTab,\n    isRecording,\n    setIsRecording,\n    setMediaURL,  \n    setCountdown,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef,\n}) {\n  const mediaType = selectedTab === 1 ? { video: true, audio: true } : { audio: true };\n\n  if (!isRecording) {\n      resetRecordingState({ setMediaURL, setCountdown, setVideoBlob, setAudioBlob, selectedTab });\n      console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n\n      navigator.mediaDevices.getUserMedia(mediaType)\n          .then((stream) => {\n              const mediaRecorder = new MediaRecorder(stream);\n              mediaRecorderRef.current = mediaRecorder;\n              mediaChunksRef.current = [];\n\n              mediaRecorder.start();\n              setIsRecording(true);\n              console.log('MediaRecorder started');\n\n              const countdownInterval = setInterval(() => {\n                  setCountdown((prev) => {\n                      if (prev <= 1) {\n                          clearInterval(countdownInterval);\n                          if (mediaRecorder.state === \"recording\") {\n                              console.log('Stopping recording due to countdown');\n                              mediaRecorder.stop();\n                              stopMediaTracks(mediaRecorderRef);\n                              setIsRecording(false);\n                          }\n                          return 0;\n                      }\n                      return prev - 1;\n                  });\n              }, 1000);\n\n              mediaRecorder.countdownInterval = countdownInterval;\n\n              mediaRecorder.addEventListener('dataavailable', (event) => {\n                  if (event.data.size > 0) {\n                      mediaChunksRef.current.push(event.data);\n                      console.log('Data chunk received:', event.data.size, 'bytes');\n                  }\n              });\n\n              mediaRecorder.addEventListener('stop', () => {\n                  const mediaBlob = new Blob(mediaChunksRef.current, {\n                      type: selectedTab === 1 ? 'video/webm' : 'audio/webm',\n                  });\n                  console.log('Created media blob:', {\n                      type: mediaBlob.type,\n                      size: mediaBlob.size,\n                  });\n\n                  const url = URL.createObjectURL(mediaBlob);\n                  setMediaURL(url);\n\n                  if (selectedTab === 1) {\n                      setVideoBlob(mediaBlob);\n                      console.log('Video blob set:', mediaBlob);\n                  } else {\n                      setAudioBlob(mediaBlob);\n                      console.log('Audio blob set:', mediaBlob);\n                  }\n\n                  setIsRecording(false);\n                  mediaChunksRef.current = [];\n                  clearInterval(mediaRecorder.countdownInterval);\n              });\n          })\n          .catch((err) => {\n              console.error('Error accessing media:', err);\n              setIsRecording(false);\n              alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n          });\n  } else {\n      if (mediaRecorderRef.current) {\n          mediaRecorderRef.current.stop();\n          stopMediaTracks(mediaRecorderRef);\n          clearInterval(mediaRecorderRef.current.countdownInterval);\n          setCountdown(0);\n          console.log('Recording stopped manually');\n      }\n  }\n}\n\nexport function handleReRecord({\n  selectedTab,\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef,\n  startNewRecording,\n}) {\n  resetRecordingState({ setMediaURL, setVideoBlob, setAudioBlob, selectedTab });\n  mediaChunksRef.current = [];\n  stopMediaTracks(mediaRecorderRef);\n\n  if (startNewRecording) {\n      startNewRecording();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}