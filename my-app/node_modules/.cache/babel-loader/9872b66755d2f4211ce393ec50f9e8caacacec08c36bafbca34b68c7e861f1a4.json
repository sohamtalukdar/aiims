{"ast":null,"code":"export default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef\n}) {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n  if (typeof setIsRecording !== \"function\") {\n    throw new Error(\"setIsRecording must be a function\");\n  }\n  if (typeof setCountdown !== \"function\") {\n    throw new Error(\"setCountdown must be a function\");\n  }\n  const mediaType = selectedTab === 1 ? {\n    video: true,\n    audio: true\n  } // Video with audio\n  : {\n    audio: true\n  }; // Audio only\n\n  if (!isRecording) {\n    // Clear previous recording state\n    setMediaURL(\"\");\n    setCountdown(60); // Reset countdown\n    if (selectedTab === 1) {\n      setVideoBlob(null);\n    } else {\n      setAudioBlob(null);\n    }\n    console.log(\"Starting media recording for:\", selectedTab === 1 ? \"video\" : \"audio\");\n\n    // Request media access\n    navigator.mediaDevices.getUserMedia(mediaType).then(stream => {\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      mediaChunksRef.current = [];\n      mediaRecorder.start();\n      setIsRecording(true);\n      console.log(\"MediaRecorder started\");\n\n      // Countdown logic\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            // Automatically stop recording when countdown reaches 0\n            if (mediaRecorder.state === \"recording\") {\n              console.log(\"Stopping recording due to countdown\");\n              mediaRecorder.stop();\n              stream.getTracks().forEach(track => track.stop());\n              setIsRecording(false);\n            }\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      mediaRecorder.countdownInterval = countdownInterval;\n\n      // Event: Data Available\n      mediaRecorder.addEventListener(\"dataavailable\", event => {\n        if (event.data.size > 0) {\n          mediaChunksRef.current.push(event.data);\n          console.log(\"Data chunk received:\", event.data.size, \"bytes\");\n        }\n      });\n\n      // Event: Stop\n      mediaRecorder.addEventListener(\"stop\", () => {\n        const mediaBlob = new Blob(mediaChunksRef.current, {\n          type: selectedTab === 1 ? \"video/webm\" : \"audio/webm\"\n        });\n        const url = URL.createObjectURL(mediaBlob);\n        setMediaURL(url);\n        if (selectedTab === 1) {\n          setVideoBlob(mediaBlob);\n          console.log(\"Video blob set:\", mediaBlob);\n        } else {\n          setAudioBlob(mediaBlob);\n          console.log(\"Audio blob set:\", mediaBlob);\n        }\n\n        // Cleanup state\n        setIsRecording(false);\n        mediaChunksRef.current = [];\n        clearInterval(mediaRecorder.countdownInterval);\n      });\n    }).catch(err => {\n      console.error(\"Error accessing media:\", err);\n      setIsRecording(false);\n      alert(`Could not access your ${selectedTab === 1 ? \"camera\" : \"microphone\"}. Please check your browser settings.`);\n    });\n  } else {\n    // Stop recording manually\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log(\"Recording stopped manually\");\n    }\n  }\n}\nexport const handleReRecord = ({\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaChunksRef,\n  mediaRecorderRef,\n  selectedTab,\n  handleMediaRecord,\n  setIsRecording,\n  setCountdown\n}) => {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n  console.log(\"Re-recording initiated\");\n\n  // Clear the current recording state\n  setMediaURL(\"\");\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n\n  // Clear media chunks\n  mediaChunksRef.current = [];\n\n  // Stop any existing streams\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n  }\n\n  // Start new recording\n  handleMediaRecord({\n    selectedTab,\n    isRecording: false,\n    setIsRecording,\n    setMediaURL,\n    setCountdown,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef\n  });\n};","map":{"version":3,"names":["handleMediaRecord","selectedTab","isRecording","setIsRecording","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","mediaRecorderRef","mediaChunksRef","Error","mediaType","video","audio","console","log","navigator","mediaDevices","getUserMedia","then","stream","mediaRecorder","MediaRecorder","current","start","countdownInterval","setInterval","prev","clearInterval","state","stop","getTracks","forEach","track","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","error","alert","handleReRecord"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["export default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef,\n}) {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n  if (typeof setIsRecording !== \"function\") {\n    throw new Error(\"setIsRecording must be a function\");\n  }\n  if (typeof setCountdown !== \"function\") {\n    throw new Error(\"setCountdown must be a function\");\n  }\n\n  const mediaType =\n    selectedTab === 1\n      ? { video: true, audio: true } // Video with audio\n      : { audio: true }; // Audio only\n\n  if (!isRecording) {\n    // Clear previous recording state\n    setMediaURL(\"\");\n    setCountdown(60); // Reset countdown\n    if (selectedTab === 1) {\n      setVideoBlob(null);\n    } else {\n      setAudioBlob(null);\n    }\n\n    console.log(\"Starting media recording for:\", selectedTab === 1 ? \"video\" : \"audio\");\n\n    // Request media access\n    navigator.mediaDevices\n      .getUserMedia(mediaType)\n      .then((stream) => {\n        const mediaRecorder = new MediaRecorder(stream);\n        mediaRecorderRef.current = mediaRecorder;\n        mediaChunksRef.current = [];\n\n        mediaRecorder.start();\n        setIsRecording(true);\n        console.log(\"MediaRecorder started\");\n\n        // Countdown logic\n        const countdownInterval = setInterval(() => {\n          setCountdown((prev) => {\n            if (prev <= 1) {\n              clearInterval(countdownInterval);\n              // Automatically stop recording when countdown reaches 0\n              if (mediaRecorder.state === \"recording\") {\n                console.log(\"Stopping recording due to countdown\");\n                mediaRecorder.stop();\n                stream.getTracks().forEach((track) => track.stop());\n                setIsRecording(false);\n              }\n              return 0;\n            }\n            return prev - 1;\n          });\n        }, 1000);\n\n        mediaRecorder.countdownInterval = countdownInterval;\n\n        // Event: Data Available\n        mediaRecorder.addEventListener(\"dataavailable\", (event) => {\n          if (event.data.size > 0) {\n            mediaChunksRef.current.push(event.data);\n            console.log(\"Data chunk received:\", event.data.size, \"bytes\");\n          }\n        });\n\n        // Event: Stop\n        mediaRecorder.addEventListener(\"stop\", () => {\n          const mediaBlob = new Blob(mediaChunksRef.current, {\n            type: selectedTab === 1 ? \"video/webm\" : \"audio/webm\",\n          });\n          const url = URL.createObjectURL(mediaBlob);\n          setMediaURL(url);\n\n          if (selectedTab === 1) {\n            setVideoBlob(mediaBlob);\n            console.log(\"Video blob set:\", mediaBlob);\n          } else {\n            setAudioBlob(mediaBlob);\n            console.log(\"Audio blob set:\", mediaBlob);\n          }\n\n          // Cleanup state\n          setIsRecording(false);\n          mediaChunksRef.current = [];\n          clearInterval(mediaRecorder.countdownInterval);\n        });\n      })\n      .catch((err) => {\n        console.error(\"Error accessing media:\", err);\n        setIsRecording(false);\n        alert(\n          `Could not access your ${selectedTab === 1 ? \"camera\" : \"microphone\"}. Please check your browser settings.`\n        );\n      });\n  } else {\n    // Stop recording manually\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log(\"Recording stopped manually\");\n    }\n  }\n}\n\nexport const handleReRecord = ({\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaChunksRef,\n  mediaRecorderRef,\n  selectedTab,\n  handleMediaRecord,\n  setIsRecording,\n  setCountdown,\n}) => {\n  // Validate required parameters\n  if (typeof setMediaURL !== \"function\") {\n    throw new Error(\"setMediaURL must be a function\");\n  }\n\n  console.log(\"Re-recording initiated\");\n\n  // Clear the current recording state\n  setMediaURL(\"\");\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n\n  // Clear media chunks\n  mediaChunksRef.current = [];\n\n  // Stop any existing streams\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n  }\n\n  // Start new recording\n  handleMediaRecord({\n    selectedTab,\n    isRecording: false,\n    setIsRecording,\n    setMediaURL,\n    setCountdown,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef,\n  });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}