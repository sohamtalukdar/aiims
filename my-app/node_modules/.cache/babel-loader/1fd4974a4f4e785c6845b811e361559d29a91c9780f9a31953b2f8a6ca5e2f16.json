{"ast":null,"code":"export default function handleMediaRecord({}) {\n  const mediaType = selectedTab === 1 ? {\n    video: true,\n    audio: true\n  } // Video with audio\n  : {\n    audio: true\n  }; // Audio only\n\n  if (!isRecording) {\n    // Clear previous recording data when starting new recording\n    setMediaURL(\"\");\n    setCountdown(60); // Reset the countdown\n    if (selectedTab === 1) {\n      setVideoBlob(null);\n    } else {\n      setAudioBlob(null);\n    }\n    console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n    navigator.mediaDevices.getUserMedia(mediaType).then(stream => {\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      mediaChunksRef.current = [];\n      mediaRecorder.start();\n      setIsRecording(true);\n      console.log('MediaRecorder started');\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            // Automatically stop recording when countdown reaches 0\n            if (mediaRecorder.state === \"recording\") {\n              console.log('Stopping recording due to countdown');\n              mediaRecorder.stop();\n              stream.getTracks().forEach(track => track.stop());\n              setIsRecording(false);\n            }\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      mediaRecorder.countdownInterval = countdownInterval;\n      mediaRecorder.addEventListener('dataavailable', event => {\n        if (event.data.size > 0) {\n          mediaChunksRef.current.push(event.data);\n          console.log('Data chunk received:', event.data.size, 'bytes');\n        }\n      });\n      mediaRecorder.addEventListener('stop', () => {\n        const mediaBlob = new Blob(mediaChunksRef.current, {\n          type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n        });\n        console.log('Created media blob:', {\n          type: mediaBlob.type,\n          size: mediaBlob.size\n        });\n        const url = URL.createObjectURL(mediaBlob);\n        setMediaURL(url);\n        if (selectedTab === 1) {\n          setVideoBlob(mediaBlob);\n          console.log('Video blob set:', mediaBlob);\n        } else {\n          setAudioBlob(mediaBlob);\n          console.log('Audio blob set:', mediaBlob);\n        }\n        setIsRecording(false);\n        mediaChunksRef.current = [];\n        clearInterval(mediaRecorder.countdownInterval);\n      });\n    }).catch(err => {\n      console.error('Error accessing media:', err);\n      setIsRecording(false);\n      alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n    });\n  } else {\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log('Recording stopped manually');\n    }\n  }\n}\n;","map":{"version":3,"names":["handleMediaRecord","mediaType","selectedTab","video","audio","isRecording","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","console","log","navigator","mediaDevices","getUserMedia","then","stream","mediaRecorder","MediaRecorder","mediaRecorderRef","current","mediaChunksRef","start","setIsRecording","countdownInterval","setInterval","prev","clearInterval","state","stop","getTracks","forEach","track","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","error","alert"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["export default function  handleMediaRecord({}){\n    const mediaType = selectedTab === 1 \n      ? { video: true, audio: true }  // Video with audio\n      : { audio: true };              // Audio only\n\n    if (!isRecording) {\n      // Clear previous recording data when starting new recording\n      setMediaURL(\"\");\n      setCountdown(60); // Reset the countdown\n      if (selectedTab === 1) {\n        setVideoBlob(null);\n      } else {\n        setAudioBlob(null);\n      }\n\n      console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n\n      navigator.mediaDevices.getUserMedia(mediaType)\n        .then((stream) => {\n          const mediaRecorder = new MediaRecorder(stream);\n          mediaRecorderRef.current = mediaRecorder;\n          mediaChunksRef.current = [];\n\n          mediaRecorder.start();\n          setIsRecording(true);\n          console.log('MediaRecorder started');\n\n          const countdownInterval = setInterval(() => {\n            setCountdown((prev) => {\n              if (prev <= 1) {\n                clearInterval(countdownInterval);\n                // Automatically stop recording when countdown reaches 0\n                if (mediaRecorder.state === \"recording\") {\n                  console.log('Stopping recording due to countdown');\n                  mediaRecorder.stop();\n                  stream.getTracks().forEach(track => track.stop());\n                  setIsRecording(false);\n                }\n                return 0;\n              }\n              return prev - 1;\n            });\n          }, 1000);\n\n          mediaRecorder.countdownInterval = countdownInterval;\n\n          mediaRecorder.addEventListener('dataavailable', (event) => {\n            if (event.data.size > 0) {\n              mediaChunksRef.current.push(event.data);\n              console.log('Data chunk received:', event.data.size, 'bytes');\n            }\n          });\n\n          mediaRecorder.addEventListener('stop', () => {\n            const mediaBlob = new Blob(mediaChunksRef.current, {\n              type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n            });\n            console.log('Created media blob:', {\n              type: mediaBlob.type,\n              size: mediaBlob.size\n            });\n\n            const url = URL.createObjectURL(mediaBlob);\n            setMediaURL(url);\n\n            if (selectedTab === 1) {\n              setVideoBlob(mediaBlob);\n              console.log('Video blob set:', mediaBlob);\n            } else {\n              setAudioBlob(mediaBlob);\n              console.log('Audio blob set:', mediaBlob);\n            }\n\n            setIsRecording(false);\n            mediaChunksRef.current = [];\n            clearInterval(mediaRecorder.countdownInterval);\n          });\n        })\n        .catch((err) => {\n          console.error('Error accessing media:', err);\n          setIsRecording(false);\n          alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n        });\n    } else {\n      if (mediaRecorderRef.current) {\n        mediaRecorderRef.current.stop();\n        mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n        clearInterval(mediaRecorderRef.current.countdownInterval);\n        setCountdown(0);\n        console.log('Recording stopped manually');\n      }\n    }\n  }; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}