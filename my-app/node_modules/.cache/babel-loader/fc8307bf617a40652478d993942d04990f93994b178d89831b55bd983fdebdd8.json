{"ast":null,"code":"// Utility function to reset recording state\nconst resetRecordingState = ({\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  selectedTab\n}) => {\n  setMediaURL(\"\");\n  setCountdown(60); // Reset the countdown\n  if (selectedTab === 1) {\n    setVideoBlob(null);\n  } else {\n    setAudioBlob(null);\n  }\n};\n\n// Utility function to stop all media tracks\nconst stopMediaTracks = mediaRecorderRef => {\n  if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n  }\n};\nexport default function handleMediaRecord({\n  selectedTab,\n  isRecording,\n  setIsRecording,\n  setMediaURL,\n  setCountdown,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef\n}) {\n  const mediaType = selectedTab === 1 ? {\n    video: true,\n    audio: true\n  } : {\n    audio: true\n  };\n  if (!isRecording) {\n    resetRecordingState({\n      setMediaURL,\n      setCountdown,\n      setVideoBlob,\n      setAudioBlob,\n      selectedTab\n    });\n    console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n    navigator.mediaDevices.getUserMedia(mediaType).then(stream => {\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      mediaChunksRef.current = [];\n      mediaRecorder.start();\n      setIsRecording(true);\n      console.log('MediaRecorder started');\n      const countdownInterval = setInterval(() => {\n        setCountdown(prev => {\n          if (prev <= 1) {\n            clearInterval(countdownInterval);\n            if (mediaRecorder.state === \"recording\") {\n              console.log('Stopping recording due to countdown');\n              mediaRecorder.stop();\n              stopMediaTracks(mediaRecorderRef);\n              setIsRecording(false);\n            }\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n      mediaRecorder.countdownInterval = countdownInterval;\n      mediaRecorder.addEventListener('dataavailable', event => {\n        if (event.data.size > 0) {\n          mediaChunksRef.current.push(event.data);\n          console.log('Data chunk received:', event.data.size, 'bytes');\n        }\n      });\n      mediaRecorder.addEventListener('stop', () => {\n        const mediaBlob = new Blob(mediaChunksRef.current, {\n          type: selectedTab === 1 ? 'video/webm' : 'audio/webm'\n        });\n        console.log('Created media blob:', {\n          type: mediaBlob.type,\n          size: mediaBlob.size\n        });\n        const url = URL.createObjectURL(mediaBlob);\n        setMediaURL(url);\n        if (selectedTab === 1) {\n          setVideoBlob(mediaBlob);\n          console.log('Video blob set:', mediaBlob);\n        } else {\n          setAudioBlob(mediaBlob);\n          console.log('Audio blob set:', mediaBlob);\n        }\n        setIsRecording(false);\n        mediaChunksRef.current = [];\n        clearInterval(mediaRecorder.countdownInterval);\n      });\n    }).catch(err => {\n      console.error('Error accessing media:', err);\n      setIsRecording(false);\n      alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n    });\n  } else {\n    if (mediaRecorderRef.current) {\n      mediaRecorderRef.current.stop();\n      stopMediaTracks(mediaRecorderRef);\n      clearInterval(mediaRecorderRef.current.countdownInterval);\n      setCountdown(0);\n      console.log('Recording stopped manually');\n    }\n  }\n}\nexport function handleReRecord({\n  selectedTab,\n  setMediaURL,\n  setVideoBlob,\n  setAudioBlob,\n  mediaRecorderRef,\n  mediaChunksRef,\n  startNewRecording\n}) {\n  resetRecordingState({\n    setMediaURL,\n    setVideoBlob,\n    setAudioBlob,\n    selectedTab\n  });\n  mediaChunksRef.current = [];\n  stopMediaTracks(mediaRecorderRef);\n  if (startNewRecording) {\n    startNewRecording();\n  }\n}","map":{"version":3,"names":["resetRecordingState","setMediaURL","setCountdown","setVideoBlob","setAudioBlob","selectedTab","stopMediaTracks","mediaRecorderRef","current","stream","getTracks","forEach","track","stop","handleMediaRecord","isRecording","setIsRecording","mediaChunksRef","mediaType","video","audio","console","log","navigator","mediaDevices","getUserMedia","then","mediaRecorder","MediaRecorder","start","countdownInterval","setInterval","prev","clearInterval","state","addEventListener","event","data","size","push","mediaBlob","Blob","type","url","URL","createObjectURL","catch","err","error","alert","handleReRecord","startNewRecording"],"sources":["/home/soham/aiims/my-app/src/handleMediaRecord.js"],"sourcesContent":["// Utility function to reset recording state\nconst resetRecordingState = ({ setMediaURL, setCountdown, setVideoBlob, setAudioBlob, selectedTab }) => {\n    setMediaURL(\"\");\n    setCountdown(60); // Reset the countdown\n    if (selectedTab === 1) {\n        setVideoBlob(null);\n    } else {\n        setAudioBlob(null);\n    }\n};\n\n// Utility function to stop all media tracks\nconst stopMediaTracks = (mediaRecorderRef) => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.stream) {\n        mediaRecorderRef.current.stream.getTracks().forEach((track) => track.stop());\n    }\n};\n\nexport default function handleMediaRecord({\n    selectedTab,\n    isRecording,\n    setIsRecording,\n    setMediaURL,\n    setCountdown,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef,\n}) {\n    const mediaType = selectedTab === 1 ? { video: true, audio: true } : { audio: true };\n\n    if (!isRecording) {\n        resetRecordingState({ setMediaURL, setCountdown, setVideoBlob, setAudioBlob, selectedTab });\n        console.log('Starting media recording for:', selectedTab === 1 ? 'video' : 'audio');\n\n        navigator.mediaDevices.getUserMedia(mediaType)\n            .then((stream) => {\n                const mediaRecorder = new MediaRecorder(stream);\n                mediaRecorderRef.current = mediaRecorder;\n                mediaChunksRef.current = [];\n\n                mediaRecorder.start();\n                setIsRecording(true);\n                console.log('MediaRecorder started');\n\n                const countdownInterval = setInterval(() => {\n                    setCountdown((prev) => {\n                        if (prev <= 1) {\n                            clearInterval(countdownInterval);\n                            if (mediaRecorder.state === \"recording\") {\n                                console.log('Stopping recording due to countdown');\n                                mediaRecorder.stop();\n                                stopMediaTracks(mediaRecorderRef);\n                                setIsRecording(false);\n                            }\n                            return 0;\n                        }\n                        return prev - 1;\n                    });\n                }, 1000);\n\n                mediaRecorder.countdownInterval = countdownInterval;\n\n                mediaRecorder.addEventListener('dataavailable', (event) => {\n                    if (event.data.size > 0) {\n                        mediaChunksRef.current.push(event.data);\n                        console.log('Data chunk received:', event.data.size, 'bytes');\n                    }\n                });\n\n                mediaRecorder.addEventListener('stop', () => {\n                    const mediaBlob = new Blob(mediaChunksRef.current, {\n                        type: selectedTab === 1 ? 'video/webm' : 'audio/webm',\n                    });\n                    console.log('Created media blob:', {\n                        type: mediaBlob.type,\n                        size: mediaBlob.size,\n                    });\n\n                    const url = URL.createObjectURL(mediaBlob);\n                    setMediaURL(url);\n\n                    if (selectedTab === 1) {\n                        setVideoBlob(mediaBlob);\n                        console.log('Video blob set:', mediaBlob);\n                    } else {\n                        setAudioBlob(mediaBlob);\n                        console.log('Audio blob set:', mediaBlob);\n                    }\n\n                    setIsRecording(false);\n                    mediaChunksRef.current = [];\n                    clearInterval(mediaRecorder.countdownInterval);\n                });\n            })\n            .catch((err) => {\n                console.error('Error accessing media:', err);\n                setIsRecording(false);\n                alert(`Could not access your ${selectedTab === 1 ? 'camera' : 'microphone'}. Please check your browser settings.`);\n            });\n    } else {\n        if (mediaRecorderRef.current) {\n            mediaRecorderRef.current.stop();\n            stopMediaTracks(mediaRecorderRef);\n            clearInterval(mediaRecorderRef.current.countdownInterval);\n            setCountdown(0);\n            console.log('Recording stopped manually');\n        }\n    }\n}\n\nexport function handleReRecord({\n    selectedTab,\n    setMediaURL,\n    setVideoBlob,\n    setAudioBlob,\n    mediaRecorderRef,\n    mediaChunksRef,\n    startNewRecording,\n}) {\n    resetRecordingState({ setMediaURL, setVideoBlob, setAudioBlob, selectedTab });\n    mediaChunksRef.current = [];\n    stopMediaTracks(mediaRecorderRef);\n\n    if (startNewRecording) {\n        startNewRecording();\n    }\n}\n"],"mappings":"AAAA;AACA,MAAMA,mBAAmB,GAAGA,CAAC;EAAEC,WAAW;EAAEC,YAAY;EAAEC,YAAY;EAAEC,YAAY;EAAEC;AAAY,CAAC,KAAK;EACpGJ,WAAW,CAAC,EAAE,CAAC;EACfC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC;EAClB,IAAIG,WAAW,KAAK,CAAC,EAAE;IACnBF,YAAY,CAAC,IAAI,CAAC;EACtB,CAAC,MAAM;IACHC,YAAY,CAAC,IAAI,CAAC;EACtB;AACJ,CAAC;;AAED;AACA,MAAME,eAAe,GAAIC,gBAAgB,IAAK;EAC1C,IAAIA,gBAAgB,CAACC,OAAO,IAAID,gBAAgB,CAACC,OAAO,CAACC,MAAM,EAAE;IAC7DF,gBAAgB,CAACC,OAAO,CAACC,MAAM,CAACC,SAAS,CAAC,CAAC,CAACC,OAAO,CAAEC,KAAK,IAAKA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;EAChF;AACJ,CAAC;AAED,eAAe,SAASC,iBAAiBA,CAAC;EACtCT,WAAW;EACXU,WAAW;EACXC,cAAc;EACdf,WAAW;EACXC,YAAY;EACZC,YAAY;EACZC,YAAY;EACZG,gBAAgB;EAChBU;AACJ,CAAC,EAAE;EACC,MAAMC,SAAS,GAAGb,WAAW,KAAK,CAAC,GAAG;IAAEc,KAAK,EAAE,IAAI;IAAEC,KAAK,EAAE;EAAK,CAAC,GAAG;IAAEA,KAAK,EAAE;EAAK,CAAC;EAEpF,IAAI,CAACL,WAAW,EAAE;IACdf,mBAAmB,CAAC;MAAEC,WAAW;MAAEC,YAAY;MAAEC,YAAY;MAAEC,YAAY;MAAEC;IAAY,CAAC,CAAC;IAC3FgB,OAAO,CAACC,GAAG,CAAC,+BAA+B,EAAEjB,WAAW,KAAK,CAAC,GAAG,OAAO,GAAG,OAAO,CAAC;IAEnFkB,SAAS,CAACC,YAAY,CAACC,YAAY,CAACP,SAAS,CAAC,CACzCQ,IAAI,CAAEjB,MAAM,IAAK;MACd,MAAMkB,aAAa,GAAG,IAAIC,aAAa,CAACnB,MAAM,CAAC;MAC/CF,gBAAgB,CAACC,OAAO,GAAGmB,aAAa;MACxCV,cAAc,CAACT,OAAO,GAAG,EAAE;MAE3BmB,aAAa,CAACE,KAAK,CAAC,CAAC;MACrBb,cAAc,CAAC,IAAI,CAAC;MACpBK,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;MAEpC,MAAMQ,iBAAiB,GAAGC,WAAW,CAAC,MAAM;QACxC7B,YAAY,CAAE8B,IAAI,IAAK;UACnB,IAAIA,IAAI,IAAI,CAAC,EAAE;YACXC,aAAa,CAACH,iBAAiB,CAAC;YAChC,IAAIH,aAAa,CAACO,KAAK,KAAK,WAAW,EAAE;cACrCb,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;cAClDK,aAAa,CAACd,IAAI,CAAC,CAAC;cACpBP,eAAe,CAACC,gBAAgB,CAAC;cACjCS,cAAc,CAAC,KAAK,CAAC;YACzB;YACA,OAAO,CAAC;UACZ;UACA,OAAOgB,IAAI,GAAG,CAAC;QACnB,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC;MAERL,aAAa,CAACG,iBAAiB,GAAGA,iBAAiB;MAEnDH,aAAa,CAACQ,gBAAgB,CAAC,eAAe,EAAGC,KAAK,IAAK;QACvD,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACrBrB,cAAc,CAACT,OAAO,CAAC+B,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;UACvChB,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAEc,KAAK,CAACC,IAAI,CAACC,IAAI,EAAE,OAAO,CAAC;QACjE;MACJ,CAAC,CAAC;MAEFX,aAAa,CAACQ,gBAAgB,CAAC,MAAM,EAAE,MAAM;QACzC,MAAMK,SAAS,GAAG,IAAIC,IAAI,CAACxB,cAAc,CAACT,OAAO,EAAE;UAC/CkC,IAAI,EAAErC,WAAW,KAAK,CAAC,GAAG,YAAY,GAAG;QAC7C,CAAC,CAAC;QACFgB,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE;UAC/BoB,IAAI,EAAEF,SAAS,CAACE,IAAI;UACpBJ,IAAI,EAAEE,SAAS,CAACF;QACpB,CAAC,CAAC;QAEF,MAAMK,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,SAAS,CAAC;QAC1CvC,WAAW,CAAC0C,GAAG,CAAC;QAEhB,IAAItC,WAAW,KAAK,CAAC,EAAE;UACnBF,YAAY,CAACqC,SAAS,CAAC;UACvBnB,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEkB,SAAS,CAAC;QAC7C,CAAC,MAAM;UACHpC,YAAY,CAACoC,SAAS,CAAC;UACvBnB,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEkB,SAAS,CAAC;QAC7C;QAEAxB,cAAc,CAAC,KAAK,CAAC;QACrBC,cAAc,CAACT,OAAO,GAAG,EAAE;QAC3ByB,aAAa,CAACN,aAAa,CAACG,iBAAiB,CAAC;MAClD,CAAC,CAAC;IACN,CAAC,CAAC,CACDgB,KAAK,CAAEC,GAAG,IAAK;MACZ1B,OAAO,CAAC2B,KAAK,CAAC,wBAAwB,EAAED,GAAG,CAAC;MAC5C/B,cAAc,CAAC,KAAK,CAAC;MACrBiC,KAAK,CAAC,yBAAyB5C,WAAW,KAAK,CAAC,GAAG,QAAQ,GAAG,YAAY,uCAAuC,CAAC;IACtH,CAAC,CAAC;EACV,CAAC,MAAM;IACH,IAAIE,gBAAgB,CAACC,OAAO,EAAE;MAC1BD,gBAAgB,CAACC,OAAO,CAACK,IAAI,CAAC,CAAC;MAC/BP,eAAe,CAACC,gBAAgB,CAAC;MACjC0B,aAAa,CAAC1B,gBAAgB,CAACC,OAAO,CAACsB,iBAAiB,CAAC;MACzD5B,YAAY,CAAC,CAAC,CAAC;MACfmB,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;IAC7C;EACJ;AACJ;AAEA,OAAO,SAAS4B,cAAcA,CAAC;EAC3B7C,WAAW;EACXJ,WAAW;EACXE,YAAY;EACZC,YAAY;EACZG,gBAAgB;EAChBU,cAAc;EACdkC;AACJ,CAAC,EAAE;EACCnD,mBAAmB,CAAC;IAAEC,WAAW;IAAEE,YAAY;IAAEC,YAAY;IAAEC;EAAY,CAAC,CAAC;EAC7EY,cAAc,CAACT,OAAO,GAAG,EAAE;EAC3BF,eAAe,CAACC,gBAAgB,CAAC;EAEjC,IAAI4C,iBAAiB,EAAE;IACnBA,iBAAiB,CAAC,CAAC;EACvB;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}